# 此文档记录想法


## 2022.7.2
- 先不考虑一帧包含逻辑循环+渲染循环的方案
- drawItem（最基础的渲染对象）
    - 渲染条目，要渲染就维护一个渲染条目，并加入到合适的drawList中
    - item渲染层级发生改变时要通知drawList更新顺序
    - drawItem应该主动合批，如瓦片地图
    - 存有状态哈希，保存关键状态，以供被动合批使用
    - 可以有渲染回调，渲染前可以通过回调执行特殊逻辑
    - 可以注册使用特殊Renderer


- drawList（一个渲染组，如：ui中某个窗口是一个组，actor对象是一个组，背景特效一个组，前景特效一个组）
    - 一个drawList对应一个Renderer，使用同一个顶点数据列表
    - drawList内部根据drawItem管理渲染顺序以及被动合批
        - 被动合批
            - 会把渲染列表中邻接的且状态哈希一致的item合并为一个复合item
            - 比如同一个面板里不同的标签对象，用的数据纹理都一样只是位置不一样
    - 交给Renderer进行渲染时要保证是最优的drawCall次数
        - 若有渲染回调则执行
        - 若有特殊Renderer则
            - 执行特殊Renderer的渲染


- drawCmd(包含整个一帧的渲染数据)
    - 管理并渲染所有的需要绘制实体的drawList



## 2022.7.3
- drawCmd
    - 包含一个唯一id
    - 包含一个特征id（用于虚拟合批）
        - 通常是纹理id
    - 包含自己的渲染数据，vao，ebo，tex等（一旦确定数据数量则不可改变，只能改变数据值）
        - 如果发生数值改变，则通知drawList需要更新此cmd的局部数据
    - 包含所属drawList，以及记录在大数组列表中的索引

- drawList
    - 注册或移除drawCmd时会在帧渲染前重置数据大数组
    - 若不重置，则把所有局部需要更新的cmd全部更新
    - 维护一份虚拟合批的cmd表
        - 在任意更新发生后重建虚拟合批的cmd表
        - 渲染时如果此cmd的id出现在虚拟cmd表中
            - 则此cmd会直接渲染记录在虚拟cmd中接下来n个cmd偏移的命令
            - 并且渲染过后跳过接下来的n个cmd
    - 渲染所有cmd


- 一个世界可以有多个drawList
- drawCmd要派生出多种类型，其中包含精灵渲染组件
- 当一个世界对象添加了精灵渲染组件时，需要指定这个组件要运行在哪个drawList下
- 渲染组件要绑定变换组件，当变换组件变动时通知渲染组件，渲染组件更新渲染数据，通知drawList更新
- 渲染节点的顺序怎么办？


## 2022.7.4
- 渲染对象
    - 包含自身vao，ebo，tex
    - 需要实现注册drawCmd的接口
        - 内部调用drawList创建cmd，并绑定自身偏移等数据
    - 需要实现获取渲染特征id的接口
    - 若自身vao数据变动，则直接用cmd通知drawList更新

- drawCmd
    - 不包含vao，ebo
    - 包含要渲染的对象句柄，渲染数据所在drawList中的偏移位置
    - 仅用作区分每次需要的drawCall，以及数据偏移

- drawList
    - 同上

- 渲染对象会向下派生出精灵渲染组件
- 当组件被加入某节点或被某节点删除时，渲染对象会设置drawList渲染前需要重构大数组的标记
- 若需要重构大数组，则由外部执行以下内容
    - 清空渲染数组
    - 遍历所有渲染对象（若是节点树，则需要按照树的顺序遍历），调用实现注册drawCmd的接口
- 若之前某渲染对象vao发生变化并被通知更新了，那么渲染前会尝试重新更新下虚拟合批表
- 重构或合批后渲染，或直接渲染
- 由于渲染顺序依赖注册顺序，所以虚拟合批表不会主动修改顺序来尝试合批，但只要满足邻接的特征id相同就会被记录



